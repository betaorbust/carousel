{"version":3,"file":"carousel-carousel-stories.ba27ff3c.iframe.bundle.js","mappings":";;;;AAoBA;;;AC6CA;;;AAKA;;;;ACrDA;;;;;;;;;;;;;;;;;AAmBA;;;;AAMA;;;;;;;;;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;;;;;;;;;;;;;;;;AAkBA","sources":["webpack://@betaorbust/carousel/./src/carousel/carousel-virtualized-list.tsx","webpack://@betaorbust/carousel/./src/carousel/carousel.tsx","webpack://@betaorbust/carousel/./src/carousel/carousel-controls.tsx","webpack://@betaorbust/carousel/./.storybook/renderable-items.tsx"],"sourcesContent":["/* @jsxImportSource @emotion/react */\nimport { css } from '@emotion/react';\nimport React from 'react';\nimport { getRealIndex } from './helpers';\n\ntype CarouselElementWrapperProps = {\n\tchildren: React.ReactNode;\n\tidentifier: string;\n\tindex: number;\n\tisCurrent: boolean;\n\tisShownToScreenReaders: boolean;\n\tonClickIndex: (index: number) => void;\n};\n\nconst elementStyle = css`\n\talign-items: stretch;\n\tflex: 1 1 auto;\n\tdisplay: flex;\n`;\n\nconst CarouselElementWrapper: React.FC<CarouselElementWrapperProps> = ({\n\tchildren,\n\tisCurrent,\n\tisShownToScreenReaders,\n\tindex,\n\tidentifier,\n\tonClickIndex,\n}) => (\n\t// Keyboard navigation is handled by the Navigation Buttons\n\t// eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions\n\t<div\n\t\taria-hidden={!isShownToScreenReaders}\n\t\tdata-virtual-index={identifier}\n\t\tclassName={isCurrent ? 'current' : undefined}\n\t\tcss={elementStyle}\n\t\tonClick={(): void => onClickIndex(index)}\n\t>\n\t\t{children}\n\t</div>\n);\n\nexport type CarouselVirtualizedListProps = {\n\ttotalBaseItems: number;\n\trenderItemAtIndex: (\n\t\tindex: number,\n\t\tvirtualIndex: number,\n\t) => React.ReactElement;\n\tstartIndex: number;\n\tendIndex: number;\n\tcurrentOverallIndex: number;\n\tonClickIndex: CarouselElementWrapperProps['onClickIndex'];\n\titemsToScreenReaders: 'none' | 'current';\n};\n\nexport const CarouselVirtualizedList: React.FC<\n\tCarouselVirtualizedListProps\n> = ({\n\tcurrentOverallIndex,\n\tendIndex,\n\tonClickIndex,\n\trenderItemAtIndex,\n\tstartIndex,\n\ttotalBaseItems,\n\titemsToScreenReaders,\n}) => {\n\t// Don't know if shakti polyfills Array.from, so we'll use the old way\n\t// eslint-disable-next-line unicorn/no-new-array\n\tconst contents = new Array(endIndex - startIndex + 1)\n\t\t.fill('')\n\t\t.map((_, i) => {\n\t\t\tconst currentIndex = startIndex + i;\n\t\t\tconst isCurrent = currentIndex === currentOverallIndex;\n\t\t\treturn (\n\t\t\t\t<CarouselElementWrapper\n\t\t\t\t\tkey={currentIndex}\n\t\t\t\t\tidentifier={`${currentIndex}`}\n\t\t\t\t\tisCurrent={isCurrent}\n\t\t\t\t\tisShownToScreenReaders={\n\t\t\t\t\t\titemsToScreenReaders === 'current' && isCurrent\n\t\t\t\t\t}\n\t\t\t\t\tonClickIndex={onClickIndex}\n\t\t\t\t\tindex={currentIndex}\n\t\t\t\t>\n\t\t\t\t\t{renderItemAtIndex(\n\t\t\t\t\t\tgetRealIndex(startIndex + i, totalBaseItems),\n\t\t\t\t\t\tstartIndex + i,\n\t\t\t\t\t)}\n\t\t\t\t</CarouselElementWrapper>\n\t\t\t);\n\t\t});\n\n\t// As far as typescript is concerned, this is not a useless fragment\n\t// eslint-disable-next-line react/jsx-no-useless-fragment\n\treturn <>{contents}</>;\n};\n","/* @jsxImportSource @emotion/react */\n\nimport React, {\n\tuseState,\n\tuseCallback,\n\tuseRef,\n\tuseEffect,\n\tuseLayoutEffect,\n} from 'react';\nimport { css } from '@emotion/react';\nimport { useSwipeable } from 'react-swipeable';\nimport { useWindowSize } from 'usehooks-ts';\nimport {\n\tCarouselVirtualizedList,\n\tCarouselVirtualizedListProps,\n} from './carousel-virtualized-list';\nimport {\n\tpositionCurrentIndex,\n\tgetRealIndex,\n\tgetNearestVirtualIndexMappingToReal,\n} from './helpers';\nimport { CarouselWidthContext } from './carousel-width-context';\n\ntype CarouselProps = {\n\tdir: 'ltr' | 'rtl';\n\t/** What to do when a user clicks on a carousel item. */\n\tonClickIndex: (index: number) => void;\n\t/** The real index in the carousel to show. */\n\tcurrentIndex: number;\n\t/** Number of real elements in the carousel. */\n\titemCount: number;\n\t/** How wide each element is. */\n\titemWidth: number;\n\t/** How many elements to have in the virtual slider */\n\tvirtualListSize: number;\n\t/** How long the animation should take in ms. */\n\tanimationDurationMs: number;\n\t/** Max swipe duration. After this it becomes a drag. */\n\tswipeMaxDurationMs: number;\n\t/** Min swipe distance. Before this, it's a tap. */\n\tswipeMinDistancePx: number;\n\t/** How to render a card at any given index */\n\trenderItemAtIndex: CarouselVirtualizedListProps['renderItemAtIndex'];\n\t/** Whether to prevent scrolling on the page when swiping or dragging. */\n\tpreventScrolling: boolean;\n\t/**\n\t * Because it's an infinite vitualized list, interaction with screen readers\n\t * is not great. This allows you to choose which items are available to\n\t * screen readers. All others will be hidden with `aria-hidden`.\n\t *\n\t * - `none`: No items are available to screen readers. Use this for situations\n\t *   where you have a separate screen reader friendly implementation or\n\t *   otherwise do not want the carousel to be read.\n\t * - `current`: Only the current item is available to screen readers. All\n\t *   others are hidden. Best in situations where the carousel is being used\n\t *   as the content of a tabbed interface.\n\t */\n\titemsToScreenReaders: CarouselVirtualizedListProps['itemsToScreenReaders'];\n};\n\nconst wrapperStyles = css`\n\tposition: relative;\n\toverflow: hidden;\n`;\n\nconst shifterStyles = css`\n\tdisplay: flex;\n\tjustify-content: stretch;\n`;\n\nconst preventDefault = (e: Event): void => {\n\te.preventDefault();\n};\n\n/**\n * A swipeable, clickable, infinitely scrolling carousel that does not itself\n * hold the state of the current index. As the parent component changes the\n * current index, the container will animate to the closest instance of that\n * index. It does this by creating a virtualized list of elements based on the\n * `renderItemAtIndex` function passed in which is in charge of rendering the\n * appropriate `<CarouselItem>` give an arbitrary index. With a fully\n * virtualized list, we can make sure there are always enough elements to fill\n * the screen.\n *\n * The component itself tries to be as dumb as possible. It does have an\n * internal index that is used to track the current index of the virtualized\n * list. Any time the parent component changes the current index, the container\n * will animate to the nearest virtual index that maps to the real index.\n *\n * On internal swipes and drags, the container will animate and update its\n * internal state before calling the parent component's onChangeIndex function\n * -- only committing the change after the action is complete.\n *\n * ```tsx\n * import { Carousel, CarouselItem } from '@betaorbust/react-carousel';\n * import { useState, useCallback } from 'react';\n *\n * const plans = ['Basic', 'Premium', 'Ultimate', 'Enterprise'];\n *\n * const Demo = () => {\n * \t// Index is controlled outside of the component so we can\n * \t// have multiple controls -- like a navigation, button or\n * \t// other carousel -- all managing the same state.\n * \tconst [currentIndex, setCurrentIndex] = useState(0);\n *\n * \t// How to render a card at any given index\n * \tconst renderItemAtIndex = useCallback(\n * \t\t// You get the real index and the virtual index\n * \t\t(index, virtualIndex) => {\n * \t\t\tconst name = plans[index];\n * \t\t\treturn (\n * \t\t\t\t// Wrap in a CarouselItem\n * \t\t\t\t<CarouselItem itemKey={`${name}-{virtualIndex}`}>\n * \t\t\t\t\t{name} at virtual index {virtualIndex}\n * \t\t\t\t</CarouselItem>\n * \t\t\t);\n * \t\t},\n * \t\t[plans],\n * \t);\n *\n * \treturn (\n * \t\t<Carousel\n * \t\t\tanimationDurationMs={500}\n * \t\t\tcurrentIndex={currentIndex}\n * \t\t\titemCount={plans.length}\n * \t\t\titemWidth={200}\n * \t\t\tonClickIndex={setCurrentIndex}\n * \t\t\tpreventScrolling={true}\n * \t\t\trenderItemAtIndex={renderItemAtIndex}\n * \t\t\tswipeMaxDurationMs={500}\n * \t\t\tswipeMinDistancePx={10}\n * \t\t\tvirtualListSize={plans.length * 3}\n * \t\t\tdir={'ltr'}\n * \t\t/>\n * \t);\n * };\n * ```\n */\nexport const Carousel: React.FC<CarouselProps> = React.memo(\n\t({\n\t\tanimationDurationMs,\n\t\tcurrentIndex,\n\t\tdir,\n\t\titemCount,\n\t\titemsToScreenReaders,\n\t\titemWidth,\n\t\tonClickIndex: onChange,\n\t\tpreventScrolling,\n\t\trenderItemAtIndex,\n\t\tswipeMaxDurationMs,\n\t\tswipeMinDistancePx,\n\t\tvirtualListSize,\n\t}) => {\n\t\tconst wrapperRef = useRef<HTMLDivElement | null>(null);\n\t\tconst shifterRef = useRef<HTMLDivElement | null>(null);\n\t\tconst [transitionPhase, setTransitionPhase] = useState<\n\t\t\t'rest' | 'move' | 'settle' | 'reconcile'\n\t\t>('rest');\n\t\t// This is in the virtualized list, so we start out childIndex offset\n\t\t// because we have a copy of all elements in front of us\n\t\tconst [internalIndex, setInternalIndex] = useState(currentIndex);\n\t\tconst [startIndex, setStartIndex] = useState(\n\t\t\tcurrentIndex - Math.round(virtualListSize / 2),\n\t\t);\n\t\tconst [endIndex, setEndIndex] = useState(\n\t\t\tcurrentIndex + Math.round(virtualListSize / 2),\n\t\t);\n\t\tconst [transform, setTransform] = useState('none');\n\t\tconst [manuallyDragging, setManuallyDragging] = useState(false);\n\t\tconst interactionRef = useRef({\n\t\t\tstartTime: 0,\n\t\t\ttouchXLast: 0,\n\t\t\ttouchXStart: 0,\n\t\t\tcarouselInitialOffset: 0,\n\t\t});\n\t\tconst dirMultiplier = dir === 'ltr' ? 1 : -1;\n\n\t\t// Re-render on window sizing changes.\n\t\tconst windowSize = useWindowSize();\n\n\t\t// Set the internal index to be the nearest virtual index\n\t\tuseEffect(\n\t\t\t() => {\n\t\t\t\tconst next = getNearestVirtualIndexMappingToReal(\n\t\t\t\t\tinternalIndex,\n\t\t\t\t\tcurrentIndex,\n\t\t\t\t\titemCount,\n\t\t\t\t);\n\t\t\t\tsetInternalIndex(next);\n\t\t\t},\n\t\t\t// We want to *not* re run this effect when the internal index\n\t\t\t// changes because we handle it elsewhere and it causes a race\n\t\t\t// condition.\n\t\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t\t[currentIndex, itemCount],\n\t\t);\n\n\t\t// If we have outstanding motions to do, kick them off\n\t\t// and then trigger a reconciliation so we can update\n\t\t// the virtual list after things have stopped moving.\n\t\tuseEffect(() => {\n\t\t\tif (\n\t\t\t\ttransitionPhase !== 'rest' ||\n\t\t\t\tinternalIndex ===\n\t\t\t\t\tgetNearestVirtualIndexMappingToReal(\n\t\t\t\t\t\tinternalIndex,\n\t\t\t\t\t\tcurrentIndex,\n\t\t\t\t\t\titemCount,\n\t\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// We're going to move!\n\t\t\tsetTransitionPhase('move');\n\t\t\t// Clean up after we're done with the transition\n\t\t\twindow.setTimeout(() => {\n\t\t\t\tsetTransitionPhase('reconcile');\n\t\t\t}, animationDurationMs + 50); // Adding 50ms to make sure we're done\n\t\t}, [\n\t\t\ttransitionPhase,\n\t\t\tcurrentIndex,\n\t\t\tinternalIndex,\n\t\t\titemCount,\n\t\t\tanimationDurationMs,\n\t\t]);\n\n\t\t// During reconciliation, update the virtual list to center the\n\t\t// current index, and provide new elements on either side.\n\t\tuseEffect(() => {\n\t\t\tif (transitionPhase === 'reconcile') {\n\t\t\t\tconst halfOfVirtualList = Math.round((virtualListSize - 1) / 2);\n\t\t\t\tsetStartIndex(() => internalIndex - halfOfVirtualList);\n\t\t\t\tsetEndIndex(() => internalIndex + halfOfVirtualList);\n\t\t\t\tsetTransitionPhase('rest');\n\t\t\t}\n\t\t}, [transitionPhase, itemCount, internalIndex, virtualListSize]);\n\n\t\t// Handle dragging internally because of the performance impact\n\t\t// that would happen if it rendered the react components on every frame.\n\t\t// It tracks manual drags, updating a ref and the raw styles in vanilla JS\n\t\t// until the drag is complete.\n\t\tconst onManualMove:\n\t\t\t| React.MouseEventHandler<HTMLDivElement> &\n\t\t\t\t\tReact.TouchEventHandler<HTMLDivElement> = useCallback(\n\t\t\t(event) => {\n\t\t\t\tif (manuallyDragging && shifterRef.current) {\n\t\t\t\t\t// This could come from a touch or a mouse event so we have to\n\t\t\t\t\t// pull the x coordinate from the right place\n\t\t\t\t\tconst x =\n\t\t\t\t\t\t'clientX' in event\n\t\t\t\t\t\t\t? event.clientX\n\t\t\t\t\t\t\t: event.touches[0].clientX;\n\n\t\t\t\t\tinteractionRef.current.touchXLast = x;\n\t\t\t\t\t// We do this live on the dom element so we don't have to\n\t\t\t\t\t// re-render every single frame\n\t\t\t\t\tshifterRef.current.style.transform = `translateX(${\n\t\t\t\t\t\tinteractionRef.current.carouselInitialOffset -\n\t\t\t\t\t\t(interactionRef.current.touchXStart -\n\t\t\t\t\t\t\tinteractionRef.current.touchXLast)\n\t\t\t\t\t}px)`;\n\t\t\t\t}\n\t\t\t},\n\t\t\t[manuallyDragging],\n\t\t);\n\n\t\t// During a manual drag, if preventScrolling is set, we attach a touchmove\n\t\t// event to kill the scroll event.\n\t\tuseEffect(() => {\n\t\t\tif (manuallyDragging && preventScrolling) {\n\t\t\t\tdocument.addEventListener('touchmove', preventDefault, {\n\t\t\t\t\tpassive: false,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdocument.removeEventListener('touchmove', preventDefault);\n\t\t\t}\n\t\t\treturn () => {\n\t\t\t\tdocument.removeEventListener('touchmove', preventDefault);\n\t\t\t};\n\t\t}, [manuallyDragging, preventScrolling]);\n\n\t\t// Initially this relied a lot more on useSwipeable, but as the complexity\n\t\t// of all our interactions grew, everything ended up having to be moved into\n\t\t// the onTouchStartOrOnMouseDown and onTouchEndOrOnMouseUp handlers, so this\n\t\t// is a good candidate for a refactor to remove the dependency and just use the\n\t\t// native handlers directly.\n\t\tconst swipeableHandlers = useSwipeable({\n\t\t\tonTouchStartOrOnMouseDown: ({ event }) => {\n\t\t\t\tsetManuallyDragging(true);\n\t\t\t\t// We start where we are\n\t\t\t\tinteractionRef.current.carouselInitialOffset =\n\t\t\t\t\tpositionCurrentIndex(internalIndex, shifterRef, wrapperRef);\n\t\t\t\tinteractionRef.current.startTime = Date.now();\n\t\t\t\tif ('clientX' in event) {\n\t\t\t\t\tinteractionRef.current.touchXStart = event.clientX;\n\t\t\t\t\tinteractionRef.current.touchXLast = event.clientX;\n\t\t\t\t} else if ('touches' in event && event.touches.length > 0) {\n\t\t\t\t\tinteractionRef.current.touchXStart =\n\t\t\t\t\t\tevent.touches[0].clientX;\n\t\t\t\t\tinteractionRef.current.touchXLast =\n\t\t\t\t\t\tevent.touches[0].clientX;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonTouchEndOrOnMouseUp: () => {\n\t\t\t\tsetManuallyDragging(false);\n\t\t\t\tconst { touchXStart, touchXLast, startTime } =\n\t\t\t\t\tinteractionRef.current;\n\t\t\t\tconst delta = touchXStart - touchXLast;\n\t\t\t\tconst deltaUnits =\n\t\t\t\t\tMath.round(delta / itemWidth) * dirMultiplier;\n\t\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t\t// Tap: < 10px movement no time limit\n\t\t\t\t// Swipe: > 10px movement < swipe time\n\t\t\t\t// Drag: > 10px movement > swipe time\n\t\t\t\tif (Math.abs(delta) < swipeMinDistancePx) {\n\t\t\t\t\t// If it was a tap, we don't want to update the index at all,\n\t\t\t\t\t// as the click handler will do that for us.\n\t\t\t\t} else {\n\t\t\t\t\tsetTransitionPhase('move');\n\t\t\t\t\t// It was a drag or swipe\n\t\t\t\t\t// If we dragged only a little bit, but did it quickly\n\t\t\t\t\t// we call that a swipe, and add an offset in the direction\n\t\t\t\t\t// of the swipe.\n\t\t\t\t\tlet swipeOffset = 0;\n\t\t\t\t\tif (deltaUnits === 0 && duration < swipeMaxDurationMs) {\n\t\t\t\t\t\tswipeOffset = (delta > 0 ? 1 : -1) * dirMultiplier;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst newInternalIndex =\n\t\t\t\t\t\tinternalIndex + deltaUnits + swipeOffset;\n\t\t\t\t\tsetInternalIndex(newInternalIndex);\n\t\t\t\t\tonChange(getRealIndex(newInternalIndex, itemCount));\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tsetTransitionPhase('reconcile');\n\t\t\t\t\t}, animationDurationMs + 50); // Adding 50ms to make sure we're done\n\t\t\t\t}\n\t\t\t},\n\t\t\tswipeDuration: 500,\n\t\t\ttouchEventOptions: { passive: false },\n\t\t\tpreventScrollOnSwipe: true,\n\t\t\ttrackMouse: true,\n\t\t});\n\n\t\t// useSwipeable uses its own ref, so we're\n\t\t// using a callback ref to get ahold of it and\n\t\t// assign that ref to our own outsideRef so we can\n\t\t// apply styles etc. to it.\n\t\tconst refPassthrough = useCallback(\n\t\t\t(el: HTMLDivElement) => {\n\t\t\t\t// call useSwipeables ref prop with el\n\t\t\t\tswipeableHandlers.ref(el);\n\t\t\t\t// set the el to a ref you can access yourself\n\t\t\t\twrapperRef.current = el;\n\t\t\t},\n\t\t\t[swipeableHandlers],\n\t\t);\n\n\t\t// Function that gets called whenever a user clicks an element\n\t\t// in the virtual list.\n\t\tconst onClickIndex = useCallback(\n\t\t\t(index: number) => {\n\t\t\t\t// Don't bother to re-render if we're already on the index\n\t\t\t\tif (transitionPhase !== 'rest') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst newRealIndex = getRealIndex(index, itemCount);\n\t\t\t\t// if (index === currentIndex && shifterRef.current) {\n\t\t\t\t// \tsetTimeout(() => {\n\t\t\t\t// \t\tif (!shifterRef.current) return;\n\t\t\t\t// \t\tconsole.log('setting back!');\n\t\t\t\t// \t\tshifterRef.current.style.transform = `translateX(${positionCurrentIndex(\n\t\t\t\t// \t\t\tinternalIndex,\n\t\t\t\t// \t\t\tshifterRef,\n\t\t\t\t// \t\t\twrapperRef,\n\t\t\t\t// \t\t)}px)`;\n\t\t\t\t// \t\tshifterRef.current.style.border = '10px solid red';\n\t\t\t\t// \t}, 10);\n\t\t\t\t// }\n\t\t\t\tonChange(newRealIndex);\n\t\t\t},\n\t\t\t[itemCount, onChange, transitionPhase],\n\t\t);\n\n\t\t// Calculate the transform to apply to the shifter element\n\t\t// unfortunately this has to be done with a useLayoutEffect\n\t\t// because we don't know how many elements are in the virtual\n\t\t// list until after the first render.\n\t\tuseLayoutEffect(\n\t\t\t() => {\n\t\t\t\tconst shift =\n\t\t\t\t\tpositionCurrentIndex(\n\t\t\t\t\t\tinternalIndex,\n\t\t\t\t\t\tshifterRef,\n\t\t\t\t\t\twrapperRef,\n\t\t\t\t\t) +\n\t\t\t\t\t// The random number is to force a re-render\n\t\t\t\t\t// of the actual dom because we modify the transform\n\t\t\t\t\t// outside of react during manual dragging, so react\n\t\t\t\t\t// doesn't know the dom has changed, and doesn't re-print\n\t\t\t\t\t// to it.\n\t\t\t\t\tMath.random() / 10_000;\n\t\t\t\tsetTransform(`translateX(${shift}px)`);\n\t\t\t},\n\t\t\t// Update between phases and any time the window size changes\n\t\t\t[\n\t\t\t\tinternalIndex,\n\t\t\t\ttransitionPhase,\n\t\t\t\twindowSize,\n\t\t\t\titemWidth,\n\t\t\t\tdir,\n\t\t\t\tmanuallyDragging,\n\t\t\t],\n\t\t);\n\n\t\t// We only use the css transition for transform when we're letting\n\t\t// the elements settle during the move phase. In reconciliation and\n\t\t// rest, we don't want the transition to happen (because we're updating\n\t\t// the virtual list, and we don't want to see the shift)\n\t\t// During manual dragging, we don't want the transition because we want\n\t\t// the elements to track as close to the touch as possible.\n\t\tconst transition =\n\t\t\ttransitionPhase === 'move' && !manuallyDragging\n\t\t\t\t? `transform ${animationDurationMs / 1000}s ease-out`\n\t\t\t\t: 'none';\n\t\treturn (\n\t\t\t<div\n\t\t\t\t// This entire component is hidden from screen readers and keyboard\n\t\t\t\t// navigation because the infinite virtual list of buttons is a terrible\n\t\t\t\t// user experience. Instead, the lower carousel navigation is focusable\n\t\t\t\t// and aria labels that match the contents of this component's children.\n\t\t\t\taria-hidden\n\t\t\t\tdir={dir}\n\t\t\t\t// eslint-disable-next-line react/jsx-props-no-spreading\n\t\t\t\t{...swipeableHandlers}\n\t\t\t\tref={refPassthrough}\n\t\t\t\tcss={wrapperStyles}\n\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\tref={shifterRef}\n\t\t\t\t\tcss={shifterStyles}\n\t\t\t\t\tonMouseMove={onManualMove}\n\t\t\t\t\tonTouchMove={onManualMove}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\ttransition,\n\t\t\t\t\t\ttransform,\n\t\t\t\t\t\t// touchAction,\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<CarouselWidthContext.Provider value={itemWidth}>\n\t\t\t\t\t\t<CarouselVirtualizedList\n\t\t\t\t\t\t\titemsToScreenReaders={itemsToScreenReaders}\n\t\t\t\t\t\t\tonClickIndex={onClickIndex}\n\t\t\t\t\t\t\tstartIndex={startIndex}\n\t\t\t\t\t\t\tendIndex={endIndex}\n\t\t\t\t\t\t\tcurrentOverallIndex={internalIndex}\n\t\t\t\t\t\t\ttotalBaseItems={itemCount}\n\t\t\t\t\t\t\trenderItemAtIndex={renderItemAtIndex}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</CarouselWidthContext.Provider>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t},\n);\n","/* @jsxImportSource @emotion/react */\nimport { css } from '@emotion/react';\nimport React from 'react';\n\ntype CarouselControlsTypes = {\n\tindexLabels: string[];\n\tonChange: (index: number) => void;\n\tcurrentIndex: number;\n\tdir: 'ltr' | 'rtl';\n};\n\nconst containerStyles = css`\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n`;\n\nconst controlsStyles = css`\n\tbackground: none;\n\tborder: none;\n\tfont-size: 1.5rem;\n\tpadding: 0.5rem 0.7rem;\n\tmargin: 0;\n\tcolor: #333;\n\ttransition: font-size 0.2s ease-in-out;\n\theight: 3rem;\n\t&:last-of-type {\n\t\tmargin-left: 1rem;\n\t}\n\t&:first-of-type {\n\t\tmargin-right: 1rem;\n\t}\n\tdisplay: flex;\n\talign-items: center;\n`;\n\nconst selectedStyle = css`\n\tbackground-color: rebeccapurple;\n\theight: 1.5rem;\n\twidth: 1.5rem;\n`;\n\nconst indicatorStyles = css`\n\tdisplay: inline-block;\n\theight: 1.1rem;\n\twidth: 1.1rem;\n\tborder: solid 2px #555;\n\tbackground-color: none;\n\tborder-radius: 50%;\n\ttransition: background-color 0.2s ease-in-out, height 0.2s ease-in-out,\n\t\twidth 0.2s ease-in-out;\n`;\n\nexport const CarouselControls: React.FC<CarouselControlsTypes> = ({\n\tindexLabels,\n\tonChange,\n\tcurrentIndex,\n\tdir,\n}) => (\n\t<div css={containerStyles} dir={dir}>\n\t\t<button\n\t\t\tcss={controlsStyles}\n\t\t\ttype=\"button\"\n\t\t\ttitle=\"Previous\"\n\t\t\tonClick={(): void =>\n\t\t\t\tonChange(\n\t\t\t\t\tcurrentIndex <= 0\n\t\t\t\t\t\t? indexLabels.length - 1\n\t\t\t\t\t\t: currentIndex - 1,\n\t\t\t\t)\n\t\t\t}\n\t\t>\n\t\t\t{dir === 'ltr' ? '◀' : '▶'}\n\t\t</button>\n\t\t{indexLabels.map((label, index) => (\n\t\t\t<button\n\t\t\t\tcss={[controlsStyles]}\n\t\t\t\ttype=\"button\"\n\t\t\t\ttitle={label}\n\t\t\t\tkey={label}\n\t\t\t\tonClick={(): void => onChange(index)}\n\t\t\t>\n\t\t\t\t<span\n\t\t\t\t\tcss={[\n\t\t\t\t\t\tindicatorStyles,\n\t\t\t\t\t\tindex === currentIndex ? selectedStyle : null,\n\t\t\t\t\t]}\n\t\t\t\t/>\n\t\t\t</button>\n\t\t))}\n\t\t<button\n\t\t\tcss={controlsStyles}\n\t\t\ttype=\"button\"\n\t\t\ttitle=\"Next\"\n\t\t\tonClick={(): void =>\n\t\t\t\tonChange(\n\t\t\t\t\tcurrentIndex >= indexLabels.length - 1\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: currentIndex + 1,\n\t\t\t\t)\n\t\t\t}\n\t\t>\n\t\t\t{dir === 'ltr' ? '▶' : '◀'}\n\t\t</button>\n\t</div>\n);\n","/* @jsxImportSource @emotion/react */\nimport React, { ComponentProps } from 'react';\nimport { css } from '@emotion/react';\nimport { CarouselItem } from '../src/carousel/carousel-item';\nimport { getRealIndex } from '../src/carousel/helpers';\nimport { Carousel } from '../src/carousel/carousel';\n\nconst elementStyles = css`\n\tdisplay: flex;\n\tflex-direction: column;\n\tjustify-content: center;\n\tpadding: 20%;\n\tborder: solid 1px gray;\n\tborder-radius: 6%;\n\tbox-sizing: border-box;\n\toverflow: hidden;\n\tmargin: 10% 3%;\n\topacity: 0.5;\n\t// This is set unrealistically high so that the animation barely starts\n\t// before we supersede the transition with the on-element style\n\ttransition: transform 10s ease-in-out, opacity 10s ease-in-out;\n\tcolor: white;\n\tz-index: 1;\n\tposition: relative;\n\tuser-select: none;\n\tbackground: linear-gradient(\n\t\t\t318.25deg,\n\t\t\t#e50914 0%,\n\t\t\trgba(74, 42, 150, 0.5) 92.16%,\n\t\t\trgba(74, 42, 150, 0) 128.15%\n\t\t),\n\t\t#1d529d;\n\t.current & {\n\t\ttransform: scale(1.15);\n\t\topacity: 1;\n\t\tz-index: 1000;\n\t}\n\th3 {\n\t\tmargin: 0;\n\t}\n`;\n\nconst indexStyle = css`\n\tposition: absolute;\n\tbottom: 4px;\n\tright: 4px;\n\tmin-width: 3em;\n\tmin-height: 3em;\n\tfont-size: 0.6em;\n\ttext-align: center;\n\tbackground-color: white;\n\tcolor: darkgray;\n\tborder-radius: 50%;\n\tborder: solid 1px gray;\n\tpadding: 5px;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n`;\n\nconst plans = [\n\t{\n\t\tname: '0. Crunch Wrap Supreme',\n\t\tprice: '$40.00',\n\t},\n\t{\n\t\tname: '1. Family, but not for Mark',\n\t\tprice: '$20.00',\n\t},\n\t{\n\t\tname: '2. Jr. One Bedroom',\n\t\tprice: '$10.00',\n\t},\n\t{\n\t\tname: `3. Please don't pick this one it's really long and it'll take up a ton of space`,\n\t\tprice: '$5.99',\n\t},\n];\n\nexport const makeIndexLabels = () => {\n\treturn plans.map(({ name }) => name);\n};\n\nexport const makeRenderItem = ({\n\tanimationDurationMs,\n}: Pick<\n\tComponentProps<typeof Carousel>,\n\t'animationDurationMs' | 'itemWidth'\n>): React.ComponentProps<typeof Carousel>['renderItemAtIndex'] => {\n\treturn (index, virtualIndex): React.ReactElement => {\n\t\tconst { name, price } = plans[index];\n\t\treturn (\n\t\t\t<CarouselItem itemKey={`${name}-virtualIndex`}>\n\t\t\t\t<div\n\t\t\t\t\tcss={elementStyles}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\ttransition: `transform ${\n\t\t\t\t\t\t\tanimationDurationMs / 1000\n\t\t\t\t\t\t}s ease-in-out, opacity ${\n\t\t\t\t\t\t\tanimationDurationMs / 1000\n\t\t\t\t\t\t}s ease-in-out`,\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<h3>{name}</h3>\n\t\t\t\t\t\t<sub>{price}</sub>\n\t\t\t\t\t\t<div css={indexStyle}>{virtualIndex}</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</CarouselItem>\n\t\t);\n\t};\n};\n"],"names":[],"sourceRoot":""}